#!/usr/bin/env node

/**
 * DAWproject Template Generator for Cubby Remote
 *
 * Generates a DAWproject XML file from expression map folders
 * Import into Cubase: File > Import > DAWproject
 *
 * Track names will exactly match expression map filenames for perfect matching!
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function getAllExpressionMaps(baseDir) {
    const results = [];

    function walk(dir, relativePath = '') {
        const entries = fs.readdirSync(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            const relPath = path.join(relativePath, entry.name);

            if (entry.isDirectory()) {
                walk(fullPath, relPath);
            } else if (entry.name.toLowerCase().endsWith('.expressionmap')) {
                const filename = entry.name.replace('.expressionmap', '');
                const folderParts = relativePath.split(path.sep).filter(Boolean);

                results.push({
                    filename,
                    folder: relativePath || 'Root',
                    folderParts,
                });
            }
        }
    }

    walk(baseDir);
    return results;
}

function generateDAWprojectXML(maps, projectName = 'Cubby Remote Template') {
    const xml = [];

    xml.push('<?xml version="1.0" encoding="UTF-8"?>');
    xml.push('<Project version="1.0">');
    xml.push('\t<Application name="Cubby Remote Generator" version="1.0.0" />');
    xml.push('\t<Transport>');
    xml.push('\t\t<Tempo unit="bpm" value="120" />');
    xml.push('\t\t<TimeSignature numerator="4" denominator="4" />');
    xml.push('\t</Transport>');
    xml.push('\t<Structure>');

    // Create MIDI instrument tracks
    let trackId = 1;

    maps.forEach((map, index) => {
        const id = 'id' + trackId;
        xml.push('\t\t<Track contentType="notes" loaded="true" id="' + id + '" name="' + escapeXml(map.filename) + '" color="#fe7272ff" />');
        trackId++;
    });

    xml.push('\t</Structure>');
    xml.push('</Project>');

    return xml.join('\n');
}

function generateMetadataXML(projectName) {
    const xml = [];
    xml.push('<?xml version="1.0" encoding="UTF-8"?>');
    xml.push('<MetaData>');
    xml.push('\t<Title>' + escapeXml(projectName) + '</Title>');
    xml.push('\t<Artist />');
    xml.push('\t<Album />');
    xml.push('\t<OriginalArtist />');
    xml.push('\t<Songwriter />');
    xml.push('\t<Producer />');
    xml.push('\t<Year />');
    xml.push('\t<Genre />');
    xml.push('\t<Copyright />');
    xml.push('\t<Comment>Generated by Cubby Remote - Track names match expression map filenames</Comment>');
    xml.push('</MetaData>');
    return xml.join('\n');
}

function escapeXml(str) {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
}

async function main() {
    console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘            DAWproject Template Generator for Cubby Remote                 â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

    // Get folder path from command line
    let folderPath = process.argv[2];
    let outputPath = process.argv[3];

    if (!folderPath) {
        console.error('  Usage: node generate-dawproject.js <expression-maps-folder> [output.dawproject]\n');
        console.error('  Example:');
        console.error('    node generate-dawproject.js "expression-maps/1 Prime/1 Wood" "VSL-Prime-Wood.dawproject"\n');
        process.exit(1);
    }

    folderPath = folderPath.trim().replace(/^["']|["']$/g, '');

    // Default output path
    if (!outputPath) {
        const folderName = path.basename(folderPath);
        outputPath = folderName.replace(/[^a-zA-Z0-9-_]/g, '-') + '.dawproject';
    }

    // Validate folder
    if (!fs.existsSync(folderPath)) {
        console.error(`\n  âœ— Error: Folder not found: ${folderPath}\n`);
        process.exit(1);
    }

    if (!fs.statSync(folderPath).isDirectory()) {
        console.error(`\n  âœ— Error: Not a directory: ${folderPath}\n`);
        process.exit(1);
    }

    console.log(`  ğŸ“ Scanning: ${folderPath}\n`);

    // Scan expression maps
    const maps = getAllExpressionMaps(folderPath);

    if (maps.length === 0) {
        console.error('  âœ— No .expressionmap files found in this folder\n');
        process.exit(0);
    }

    console.log(`  âœ“ Found ${maps.length} expression map(s)\n`);

    console.log('  Preview of tracks to be created:\n');
    maps.forEach((map, i) => {
        console.log(`  ${(i + 1).toString().padStart(3)}. ğŸ¹ ${map.filename}`);
    });
    console.log('');

    // Generate DAWproject XML
    const projectName = path.basename(folderPath) + ' Template';
    const projectXml = generateDAWprojectXML(maps, projectName);
    const metadataXml = generateMetadataXML(projectName);

    // DAWproject files are ZIP archives containing project.xml and metadata.xml
    // Create temp directory
    const tempDir = path.join(__dirname, '.dawproject-temp-' + Date.now());
    fs.mkdirSync(tempDir, { recursive: true });

    try {
        // Write XML files to temp directory
        const projectXmlPath = path.join(tempDir, 'project.xml');
        const metadataXmlPath = path.join(tempDir, 'metadata.xml');
        fs.writeFileSync(projectXmlPath, projectXml, 'utf-8');
        fs.writeFileSync(metadataXmlPath, metadataXml, 'utf-8');

        // Create ZIP archive using PowerShell (Windows) or zip (Mac/Linux)
        const absoluteOutputPath = path.resolve(outputPath);
        const tempZipPath = absoluteOutputPath.replace(/\.dawproject$/i, '.zip');

        if (process.platform === 'win32') {
            // Windows: Use PowerShell Compress-Archive (only supports .zip)
            const psCommand = `Compress-Archive -Path "${tempDir}\\*" -DestinationPath "${tempZipPath}" -Force`;
            execSync(`powershell -Command "${psCommand}"`, { stdio: 'pipe' });

            // Rename .zip to .dawproject
            if (tempZipPath !== absoluteOutputPath) {
                if (fs.existsSync(absoluteOutputPath)) {
                    fs.unlinkSync(absoluteOutputPath);
                }
                fs.renameSync(tempZipPath, absoluteOutputPath);
            }
        } else {
            // Mac/Linux: Use zip command (supports any extension)
            execSync(`cd "${tempDir}" && zip -q "${absoluteOutputPath}" project.xml`, { stdio: 'pipe' });
        }

        console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘                            SUCCESS!                                       â•‘');
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
        console.log(`  âœ“ Generated: ${outputPath}`);
        console.log(`  âœ“ Tracks: ${maps.length}`)
        console.log(`  âœ“ Format: DAWproject (ZIP archive with project.xml)\n`);

    } finally {
        // Clean up temp directory
        fs.rmSync(tempDir, { recursive: true, force: true });
    }
    console.log('  Next steps:\n');
    console.log('  1. Open Cubase');
    console.log('  2. File > Import > DAWproject...');
    console.log(`  3. Select: ${outputPath}`);
    console.log('  4. Track names will exactly match expression map filenames!');
    console.log('  5. Assign expression maps to tracks in Cubase');
    console.log('  6. Track switching will work perfectly! âœ¨\n');
}

main().catch(error => {
    console.error('\n  âœ— Unexpected error:', error.message, '\n');
    process.exit(1);
});
